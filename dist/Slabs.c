/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/build/setup2/karamel/krml -skip-compilation -fparentheses -tmpdir dist -library Steel.ArrayArith -static-header Steel.ArrayArith -no-prefix Steel.ArrayArith -bundle Steel.SpinLock= -bundle FStar.\*,Steel.\* -bundle StarMalloc=Map.\*,Impl.\*,Spec.\*,Main,Main.Meta,LargeAlloc[rename=StarMalloc] -bundle SlabsCommon,SlabsFree,SlabsAlloc[rename=Slabs] -bundle SlotsFree,SlotsAlloc[rename=Slots] -bundle ArrayList,ArrayListGen[rename=ArrayList] -no-prefix Main -no-prefix LargeAlloc -no-prefix Mman -no-prefix MemoryTrap -warn-error +9 -add-include Steel_SpinLock:"steel_types.h" -add-include Steel_SpinLock:"steel_base.h" obj/prims.krml obj/FStar_Pervasives_Native.krml obj/FStar_Pervasives.krml obj/FStar_Mul.krml obj/FStar_Squash.krml obj/FStar_Classical.krml obj/FStar_Preorder.krml obj/FStar_Sealed.krml obj/FStar_Range.krml obj/FStar_Calc.krml obj/FStar_StrongExcludedMiddle.krml obj/FStar_Classical_Sugar.krml obj/FStar_List_Tot_Base.krml obj/FStar_List_Tot_Properties.krml obj/FStar_List_Tot.krml obj/FStar_Seq_Base.krml obj/FStar_Seq_Properties.krml obj/FStar_Seq.krml obj/FStar_Math_Lib.krml obj/FStar_Math_Lemmas.krml obj/FStar_BitVector.krml obj/FStar_UInt.krml obj/FStar_UInt32.krml obj/FStar_Int.krml obj/FStar_Int16.krml obj/Seq2.krml obj/Bitmap1.krml obj/Bitmap2.krml obj/FStar_UInt64.krml obj/Bitmap3.krml obj/Bitmap4.krml obj/FStar_Int64.krml obj/FStar_Int32.krml obj/FStar_Int8.krml obj/FStar_UInt16.krml obj/FStar_UInt8.krml obj/FStar_Int_Cast.krml obj/FStar_Ghost.krml obj/FStar_SizeT.krml obj/SeqUtils.krml obj/FStar_VConfig.krml obj/FStar_Float.krml obj/FStar_Char.krml obj/FStar_Pprint.krml obj/FStar_Issue.krml obj/FStar_TypeChecker_Core.krml obj/FStar_Tactics_Common.krml obj/FStar_Reflection_Types.krml obj/FStar_Tactics_Types.krml obj/FStar_Tactics_Result.krml obj/FStar_Monotonic_Pure.krml obj/FStar_Tactics_Effect.krml obj/FStar_Tactics_Unseal.krml obj/FStar_Sealed_Inhabited.krml obj/FStar_Syntax_Syntax.krml obj/FStar_Reflection_V2_Data.krml obj/FStar_Order.krml obj/FStar_Reflection_V2_Builtins.krml obj/FStar_Reflection_Const.krml obj/FStar_Tactics_V2_Builtins.krml obj/FStar_Tactics_SMT.krml obj/FStar_Tactics_Util.krml obj/FStar_Reflection_V2_Derived.krml obj/FStar_Reflection_V2_Compare.krml obj/FStar_Reflection_V2_Derived_Lemmas.krml obj/FStar_Reflection_V2.krml obj/FStar_Tactics_Visit.krml obj/FStar_Tactics_NamedView.krml obj/FStar_PropositionalExtensionality.krml obj/FStar_Reflection_V1_Data.krml obj/FStar_Reflection_V1_Builtins.krml obj/FStar_Tactics_V1_Builtins.krml obj/FStar_Tactics_Builtins.krml obj/FStar_Tactics_V2_SyntaxCoercions.krml obj/FStar_Tactics_V2_SyntaxHelpers.krml obj/FStar_Reflection_V2_Formula.krml obj/FStar_Tactics_V2_Derived.krml obj/FStar_Tactics_Print.krml obj/FStar_IndefiniteDescription.krml obj/FStar_Reflection_V1_Derived.krml obj/FStar_Reflection_V1_Formula.krml obj/FStar_Reflection_V1_Compare.krml obj/FStar_Reflection_V1_Derived_Lemmas.krml obj/FStar_Reflection_V1.krml obj/FStar_Tactics_V1_SyntaxHelpers.krml obj/FStar_Tactics_V1_Derived.krml obj/FStar_Tactics_V1_Logic.krml obj/FStar_Tactics_V1.krml obj/FStar_Tactics.krml obj/FStar_PtrdiffT.krml obj/FStar_Real.krml obj/Steel_FractionalPermission.krml obj/FStar_Witnessed_Core.krml obj/FStar_MSTTotal.krml obj/FStar_NMSTTotal.krml obj/FStar_PCM.krml obj/Steel_Preorder.krml obj/FStar_FunctionalExtensionality.krml obj/FStar_Set.krml obj/FStar_PredicateExtensionality.krml obj/FStar_WellFounded.krml obj/FStar_Universe.krml obj/Steel_Heap.krml obj/Steel_Memory.krml obj/FStar_MST.krml obj/FStar_NMST.krml obj/Steel_Semantics_Hoare_MST.krml obj/Steel_Semantics_Instantiate.krml obj/FStar_Exn.krml obj/FStar_Monotonic_Witnessed.krml obj/FStar_ErasedLogic.krml obj/FStar_TSet.krml obj/FStar_Monotonic_Heap.krml obj/FStar_Heap.krml obj/FStar_ST.krml obj/FStar_All.krml obj/FStar_List.krml obj/FStar_String.krml obj/FStar_Tactics_Typeclasses.krml obj/FStar_Tactics_MApply.krml obj/FStar_Tactics_V2_Logic.krml obj/FStar_Tactics_V2.krml obj/FStar_Tactics_CanonCommSwaps.krml obj/FStar_Algebra_CommMonoid_Equiv.krml obj/FStar_Tactics_CanonCommMonoidSimple_Equiv.krml obj/Steel_Effect_Common.krml obj/Steel_Effect.krml obj/Steel_Effect_Atomic.krml obj/Steel_ST_Effect.krml obj/Steel_ST_Effect_AtomicAndGhost.krml obj/Steel_ST_Effect_Atomic.krml obj/Steel_ST_Effect_Ghost.krml obj/Steel_ST_Coercions.krml obj/Steel_PCMReference.krml obj/Steel_PCMFrac.krml obj/Steel_HigherReference.krml obj/Steel_Reference.krml obj/Steel_Loops.krml obj/Steel_ST_Util.krml obj/Steel_ST_Loops.krml obj/Steel_ST_Reference.krml obj/FStar_Map.krml obj/Steel_PCMMap.krml obj/Steel_ST_PCMReference.krml obj/Steel_ST_HigherArray.krml obj/Steel_ST_Array.krml obj/Steel_Array.krml obj/Prelude.krml obj/Config.krml obj/Utils2.krml obj/NullOrVarray.krml obj/Steel_ArrayArith.krml obj/Bitmap5.krml obj/SteelVRefineDep.krml obj/SteelOptUtils.krml obj/SteelStarSeqUtils.krml obj/SlotsAlloc.krml obj/MemoryTrap.krml obj/Quarantine.krml obj/FStar_FiniteSet_Base.krml obj/RingBuffer.krml obj/FStar_FiniteSet_Ambient.krml obj/Steel_ArrayRef.krml obj/ArrayListGen.krml obj/ArrayList.krml obj/Helpers.krml obj/SetUtils.krml obj/Guards.krml obj/SteelVRefine2.krml obj/SlabsCommon.krml obj/SlotsFree.krml obj/SlabsFree.krml obj/MiscArith.krml obj/SlabsAlloc.krml obj/SizeClass.krml obj/Steel_SpinLock.krml obj/Mman.krml obj/Spec_Trees.krml obj/Spec_BST.krml obj/Impl_Common.krml obj/Steel_TLArray.krml obj/Main.krml obj/Impl_Core.krml obj/Impl_Trees_Types.krml obj/Impl_Trees_M.krml obj/Spec_AVL.krml obj/Spec.krml obj/Impl_BST_M.krml obj/Impl_Trees_Rotate3_M.krml obj/Impl_Trees_Rotate2_M.krml obj/Impl_Trees_Rotate_M.krml obj/Impl_AVL_M.krml obj/Impl_Mono.krml obj/Map_M.krml obj/LargeAlloc.krml obj/ROArray.krml obj/Main_Meta.krml obj/StarMalloc.krml
  F* version: e27ee692
  KaRaMeL version: a7be2a7c
 */

#include "internal/Slabs.h"

#include "internal/Slots.h"
#include "internal/ArrayList.h"

bool
SlabsFree_deallocate_slab(
  uint8_t *ptr,
  uint32_t size_class,
  uint8_t *slab_region,
  uint64_t *md_bm_region,
  ArrayList_cell *md_region,
  size_t *md_count,
  size_t *r1,
  size_t *r2,
  size_t *r3,
  size_t *r4,
  size_t *r5,
  size_t *r_ringbuffer,
  size_t *r_in,
  size_t *r_out,
  size_t *r_size,
  size_t diff_
)
{
  KRML_MAYBE_UNUSED_VAR(r1);
  KRML_MAYBE_UNUSED_VAR(r4);
  size_t md_count_v_ = *md_count;
  size_t idx2_ = *r2;
  size_t idx3_ = *r3;
  size_t idx5_ = *r5;
  size_t pos = diff_ / (size_t)4096U;
  size_t pos2 = diff_ % (size_t)4096U;
  if (pos < md_count_v_)
  {
    uint32_t status1 = ArrayList_read_in_place(md_region, pos);
    if (status1 == 2U)
    {
      uint64_t *ptr10 = md_bm_region;
      size_t shift_size_t0 = pos * (size_t)4U;
      uint8_t *ptr11 = slab_region;
      size_t page_size_t0 = (size_t)4096U;
      size_t shift_size_t1 = pos * page_size_t0;
      bool
      b =
        SlotsFree_deallocate_slot(size_class,
          ptr10 + shift_size_t0,
          ptr11 + shift_size_t1,
          ptr,
          pos2);
      if (b)
      {
        uint64_t *ptr1 = md_bm_region;
        size_t shift_size_t = pos * (size_t)4U;
        bool r6 = Utils2_is_empty_s(size_class, ptr1 + shift_size_t);
        bool cond = r6;
        if (cond)
        {
          uint8_t *ptr1 = slab_region;
          size_t page_size_t = (size_t)4096U;
          size_t shift_size_t = pos * page_size_t;
          mmap_strict_trap(ptr1 + shift_size_t, (size_t)4096U);
          RingBuffer_ring_bufferenqueue(r_ringbuffer, r_in, r_out, r_size, pos);
          size_t v = ArrayList_remove(md_region, idx3_, pos);
          size_t idx3_ = v;
          ArrayList_insert(md_region, idx5_, pos, 4U);
          *r3 = idx3_;
          *r5 = pos;
          return b;
        }
        else
        {
          size_t v = ArrayList_remove(md_region, idx3_, pos);
          size_t idx3_ = v;
          ArrayList_insert(md_region, idx2_, pos, 1U);
          *r3 = idx3_;
          *r2 = pos;
          return b;
        }
      }
      else
        return b;
    }
    else if (status1 == 1U)
    {
      uint64_t *ptr10 = md_bm_region;
      size_t shift_size_t0 = pos * (size_t)4U;
      uint8_t *ptr11 = slab_region;
      size_t page_size_t0 = (size_t)4096U;
      size_t shift_size_t1 = pos * page_size_t0;
      bool
      b =
        SlotsFree_deallocate_slot(size_class,
          ptr10 + shift_size_t0,
          ptr11 + shift_size_t1,
          ptr,
          pos2);
      if (b)
      {
        uint64_t *ptr1 = md_bm_region;
        size_t shift_size_t = pos * (size_t)4U;
        bool r6 = Utils2_is_empty_s(size_class, ptr1 + shift_size_t);
        bool cond = r6;
        if (cond)
        {
          uint8_t *ptr1 = slab_region;
          size_t page_size_t = (size_t)4096U;
          size_t shift_size_t = pos * page_size_t;
          mmap_strict_trap(ptr1 + shift_size_t, (size_t)4096U);
          RingBuffer_ring_bufferenqueue(r_ringbuffer, r_in, r_out, r_size, pos);
          size_t v = ArrayList_remove(md_region, idx2_, pos);
          size_t idx2_ = v;
          ArrayList_insert(md_region, idx5_, pos, 4U);
          *r2 = idx2_;
          *r5 = pos;
          return b;
        }
        else
          return b;
      }
      else
        return b;
    }
    else
      return false;
  }
  else
    return false;
}

static void allocate_slab_aux_3_3_2_2(uint8_t *slab_region, size_t md_count_v)
{
  uint8_t *ptr = slab_region;
  size_t page_size_t = (size_t)4096U;
  size_t shift_size_t = (md_count_v + (size_t)1U) * page_size_t;
  mmap_strict_trap(ptr + shift_size_t, (size_t)4096U);
}

static void allocate_slab_aux_3_3_2(uint8_t *slab_region, size_t md_count_v)
{
  allocate_slab_aux_3_3_2_2(slab_region, md_count_v);
}

static void allocate_slab_aux_3_3(uint8_t *slab_region, size_t md_count_v)
{
  allocate_slab_aux_3_3_2(slab_region, md_count_v);
}

typedef struct bounded_pair__s
{
  size_t x;
  size_t y;
}
bounded_pair_;

static bounded_pair_
allocate_slab_aux_4(
  uint8_t *slab_region,
  ArrayList_cell *md_region,
  size_t *r1,
  size_t *r5,
  size_t idx1,
  size_t idx5,
  size_t *r_ringbuffer,
  size_t *r_in,
  size_t *r_out,
  size_t *r_size
)
{
  size_t idx = RingBuffer_ring_bufferdequeue(r_ringbuffer, r_in, r_out, r_size);
  uint8_t *ptr = slab_region;
  size_t page_size_t = (size_t)4096U;
  size_t shift_size_t = idx * page_size_t;
  mmap_untrap(ptr + shift_size_t, (size_t)4096U);
  size_t v = ArrayList_remove(md_region, idx5, idx);
  size_t idx5_ = v;
  ArrayList_insert(md_region, idx1, idx, 0U);
  bounded_pair_ idxs = { .x = idx, .y = idx5_ };
  *r1 = idxs.x;
  *r5 = idxs.y;
  return idxs;
}

uint8_t
*SlabsAlloc_allocate_slab(
  uint32_t size_class,
  uint8_t *slab_region,
  uint64_t *md_bm_region,
  ArrayList_cell *md_region,
  size_t *md_count,
  size_t *r1,
  size_t *r2,
  size_t *r3,
  size_t *r4,
  size_t *r5,
  size_t *r_ringbuffer,
  size_t *r_in,
  size_t *r_out,
  size_t *r_size
)
{
  size_t md_count_v_ = *md_count;
  size_t idx1_ = *r1;
  size_t idx2_ = *r2;
  size_t idx3_ = *r3;
  size_t idx4_ = *r4;
  size_t idx5_ = *r5;
  if (idx2_ != (size_t)16777216U + (size_t)1U)
  {
    uint64_t *ptr0 = md_bm_region;
    size_t shift_size_t0 = idx2_ * (size_t)4U;
    uint8_t *ptr1 = slab_region;
    size_t page_size_t = (size_t)4096U;
    size_t shift_size_t1 = idx2_ * page_size_t;
    uint8_t *r0 = SlotsAlloc_allocate_slot(size_class, ptr0 + shift_size_t0, ptr1 + shift_size_t1);
    uint64_t *ptr = md_bm_region;
    size_t shift_size_t = idx2_ * (size_t)4U;
    bool r6 = Utils2_is_full_s(size_class, ptr + shift_size_t);
    bool cond = r6;
    uint8_t *r;
    if (cond)
    {
      size_t v = ArrayList_remove(md_region, idx2_, idx2_);
      size_t idx2_0 = v;
      ArrayList_insert(md_region, idx3_, idx2_, 2U);
      *r2 = idx2_0;
      *r3 = idx2_;
      r = r0;
    }
    else
      r = r0;
    uint8_t *r1 = r;
    return r1;
  }
  else if (idx1_ != (size_t)16777216U + (size_t)1U)
  {
    uint64_t *ptr0 = md_bm_region;
    size_t shift_size_t0 = idx1_ * (size_t)4U;
    uint8_t *ptr1 = slab_region;
    size_t page_size_t = (size_t)4096U;
    size_t shift_size_t1 = idx1_ * page_size_t;
    uint8_t *r0 = SlotsAlloc_allocate_slot(size_class, ptr0 + shift_size_t0, ptr1 + shift_size_t1);
    uint64_t *ptr = md_bm_region;
    size_t shift_size_t = idx1_ * (size_t)4U;
    bool r6 = Utils2_is_full_s(size_class, ptr + shift_size_t);
    bool cond = r6;
    uint8_t *r;
    if (cond)
    {
      size_t idx1_0 = ArrayList_remove(md_region, idx1_, idx1_);
      ArrayList_insert(md_region, idx3_, idx1_, 2U);
      *r1 = idx1_0;
      *r3 = idx1_;
      r = r0;
    }
    else
    {
      size_t idx1_0 = ArrayList_remove(md_region, idx1_, idx1_);
      ArrayList_insert(md_region, idx2_, idx1_, 1U);
      *r1 = idx1_0;
      *r2 = idx1_;
      r = r0;
    }
    uint8_t *r1 = r;
    return r1;
  }
  else
  {
    size_t size = RingBuffer_ring_getsize(r_ringbuffer, r_in, r_out, r_size);
    bool b = size > (size_t)0U;
    if (b)
    {
      bounded_pair_
      idxs =
        allocate_slab_aux_4(slab_region,
          md_region,
          r1,
          r5,
          idx1_,
          idx5_,
          r_ringbuffer,
          r_in,
          r_out,
          r_size);
      uint64_t *ptr0 = md_bm_region;
      size_t shift_size_t0 = idxs.x * (size_t)4U;
      uint8_t *ptr1 = slab_region;
      size_t page_size_t = (size_t)4096U;
      size_t shift_size_t1 = idxs.x * page_size_t;
      uint8_t
      *r0 = SlotsAlloc_allocate_slot(size_class, ptr0 + shift_size_t0, ptr1 + shift_size_t1);
      uint64_t *ptr = md_bm_region;
      size_t shift_size_t = idxs.x * (size_t)4U;
      bool r6 = Utils2_is_full_s(size_class, ptr + shift_size_t);
      bool cond = r6;
      uint8_t *r;
      if (cond)
      {
        size_t idx1_ = ArrayList_remove(md_region, idxs.x, idxs.x);
        ArrayList_insert(md_region, idx3_, idxs.x, 2U);
        *r1 = idx1_;
        *r3 = idxs.x;
        r = r0;
      }
      else
      {
        size_t idx1_ = ArrayList_remove(md_region, idxs.x, idxs.x);
        ArrayList_insert(md_region, idx2_, idxs.x, 1U);
        *r1 = idx1_;
        *r2 = idxs.x;
        r = r0;
      }
      uint8_t *r1 = r;
      return r1;
    }
    else
    {
      size_t md_count_v_0 = *md_count;
      bool b1 = md_count_v_0 + (size_t)2U <= (size_t)16777216U;
      if (b1)
      {
        ArrayList_insert(md_region, idx1_, md_count_v_, 0U);
        ArrayList_extend_insert((size_t)2U,
          (size_t)0U,
          md_region,
          idx2_,
          idx3_,
          idx4_,
          idx5_,
          md_count_v_,
          0U);
        ArrayList_insert(md_region, idx4_, md_count_v_ + (size_t)2U - (size_t)1U, 3U);
        allocate_slab_aux_3_3(slab_region, md_count_v_);
        size_t v = *md_count;
        *md_count = v + (size_t)2U;
        *r1 = v + (size_t)2U - (size_t)2U;
        *r4 = v + (size_t)2U - (size_t)1U;
        uint64_t *ptr0 = md_bm_region;
        size_t shift_size_t0 = (md_count_v_ + (size_t)2U - (size_t)2U) * (size_t)4U;
        uint8_t *ptr1 = slab_region;
        size_t page_size_t = (size_t)4096U;
        size_t shift_size_t1 = (md_count_v_ + (size_t)2U - (size_t)2U) * page_size_t;
        uint8_t
        *r0 = SlotsAlloc_allocate_slot(size_class, ptr0 + shift_size_t0, ptr1 + shift_size_t1);
        uint64_t *ptr = md_bm_region;
        size_t shift_size_t = (md_count_v_ + (size_t)2U - (size_t)2U) * (size_t)4U;
        bool r6 = Utils2_is_full_s(size_class, ptr + shift_size_t);
        bool cond = r6;
        uint8_t *r;
        if (cond)
        {
          size_t
          idx1_ =
            ArrayList_remove(md_region,
              md_count_v_ + (size_t)2U - (size_t)2U,
              md_count_v_ + (size_t)2U - (size_t)2U);
          ArrayList_insert(md_region, idx3_, md_count_v_ + (size_t)2U - (size_t)2U, 2U);
          *r1 = idx1_;
          *r3 = md_count_v_ + (size_t)2U - (size_t)2U;
          r = r0;
        }
        else
        {
          size_t
          idx1_ =
            ArrayList_remove(md_region,
              md_count_v_ + (size_t)2U - (size_t)2U,
              md_count_v_ + (size_t)2U - (size_t)2U);
          ArrayList_insert(md_region, idx2_, md_count_v_ + (size_t)2U - (size_t)2U, 1U);
          *r1 = idx1_;
          *r2 = md_count_v_ + (size_t)2U - (size_t)2U;
          r = r0;
        }
        uint8_t *r1 = r;
        return r1;
      }
      else
        return NULL;
    }
  }
}

