Document de travail écrit en français, à changer...

Constats :
1) La vérification de fonctions Steel raisonnablement complexes
peut prendre un temps assez important.
La limite ne se trouve pas du côté de z3 mais de l'encodage fait par
F*.
2) La difficulté que le constat 1 amène se situe essentiellement lors
de la phase de développement, la vérification pouvant être faite sans
interaction lorsque besoin est.
3) L'apport de la vérification partiellement déchargée vers un solveur
se situe aussi dans la lisibilité du code/des preuves obtenues.

Contexte : développement d'une petite librairie avec Steel, avant
d'enchaîner sur une thèse portant a priori sur le développement
de composants de systèmes d'exploitation vérifiés en Steel.

Possibilités.
A) Ne rien changer.
B) Changer l'encodage.
C) Pousser le développement vers de la vérification incrémentale.
D) Changer le mode de développement (avec l'encodage).

A) La situation n'est pas si problématique.
En effet, utilisation actuelle d'une machine peu puissante (ordi portable
d'il y a 6 ans), alors que machines dispo par ailleurs (usage possible de 
TRAMP).
De plus, une librairie est possiblement le cas le plus pénible de
développement : l'essentiel de la complexité de la vérification est supposée
se situer au niveau des primitives. (?)
Alternativement, il reste toujours possible de découper des fonctions
complexes en fonctions auxiliaires plus rapides à vérifier.

B) A l'air vraiment complexe.
L'exemple de la PR [1] pour éviter des difficultés de typage de
la clause assume d'une fonction Steel lorsque ce typage repose sur la clause
requires le montre. (?)
Quelles possibilités ?
- Refonte majeure, autre formalisme que WP
- Solution hybride entre Steel.ST et Steel avec sélecteurs
- Parallélisme

C) Le constat 2 est essentiel. Quelle solution peut-on y apporter ?
Lors du développement d'une fonction Steel, de nombreuses assertions
peuvent être utiles pour le déboguage. Ces assertions entraînent
un temps de vérification plus long.
Pourtant, généralement, la validité de ces assertions "temporaires"
ne changent pas énormément d'une itération à une autre lors du
développement de la fonction initialement considérée.
La même remarque est valable à l'échelle de fichiers/lien avec le .fsti.
Difficile en F* d'avoir de l'analyse de dépendances fine pour faire
quelque chose d'incrémental. (?) *1
Ainsi, le développement serait moins long, avec un éditeur interactif
potentiellement plus complexe donc moins robuste, mais une méthode
de vérification inchangée lors des phases de compilation/extraction.
Garder des .checked sous la forme d'arbres ?

D) Mentionnée en A), la possibilité de découper ses fonctions en plus
petites fonctions auxiliaires est intéressante.
Le problème est qu'elle ne règle pas la question du temps de développement
total, particulièrement le besoin d'avoir des itérations courtes pour
avancer vite.
En effet, découper son code en fonctions auxiliaires résulte en une
perte de temps assez importante, et fait perdre en lisibilité au code.
Possible de pallier ça en ayant des fichiers .fsti bien fournis,
mais le constat 3 reste présent.

Idée : on a envie de pouvoir appliquer une stratégie diviser pour régner
à la vérification de code Steel. Le style monadique de Steel mène à des
difficultés, car il n'est pas évident de préciser dans quel état est la monade
sous-jacente à une position donnée du code à vérifier, sans...
vérifier l'ensemble du code.

Parallèle : lors du développement d'une petite librairie en Steel,
l'organisation suivante a été prise :
- spécification en F* (Trees.fst) ;
- modélisation de la structure mémoire (NTreeC3.fst{,i}) en F*/Steel ;
- primitives accessibles en Steel (P1.fst{,i}) ;
- utilisation en Steel après monomorphisation (P1_UInt32.fst).
A un moment donné, j'ai étendu des fonctions de la spec pour qu'elles
ne retournent pas que le résultat, mais également des valeurs intermédiaires
utiles au calcul du résultat final. Ceci m'a un peu aidé pour certaines preuves,
même si j'ai pu à la fin m'épargner l'usage de cette astuce.
De manière beaucoup plus générale, il est fréquent que des preuves en F* consistent
partiellement en de la duplication du code de la fonction sur laquelle on veut prouver
une propriété.
Pourquoi ne pas permettre le référencement explicite de valeurs intermédiaires de
la spécification depuis Steel ?
<insérer exemple convaicant>
Comment définir des points clairs de découpage ?...
Par rapport à la fonction de la spec/implem de référence,
une fois rendue accessible ?

[1] https://github.com/FStarLang/FStar/pull/2436

*1 regarder fstar.exe --dep
